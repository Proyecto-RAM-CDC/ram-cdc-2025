// DOMAIN/auth
// DOMAIN/auth?mode=login
// DOMAIN/auth?mode=signup
import { useRouteError } from "@remix-run/react";
import { ErrorBody } from "~/utilities/ErrorBody";
import AuthForm from "~/components/auth/AuthForm";
import {
  validateLoginInput,
  validateSignUpInput,
} from "~/server/validation.server";

import { signup, login } from "~/server/auth.server";
import { ActionFunctionArgs } from "@remix-run/node";
import {
  LoginCredentials,
  SignupCredentials,
  AuthMode,
} from "~/utilities/types";

// // Custom ValidationError class for better error handling.
class ValidationError extends Error {
  statusCode: number;

  constructor(message: string, statusCode: number = 400) {
    super(message);
    this.name = "ValidationError";
    this.statusCode = statusCode;

    // Fix prototype chain.
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
}

const isAuthMode = (value: string | null): value is AuthMode =>
  ["login", "signup", "forgot-password"].includes(value ?? "");

async function getAuthModeFromRequest(request: Request): Promise<AuthMode> {
  const searchParams = new URL(request.url).searchParams;
  const mode = searchParams.get("mode");
  // Since 'authMode' isn't returned with the `Form` from component 'AuthForm', we need to
  // define the same default value for 'authMode' here as was done in 'AuthForm'.
  return isAuthMode(mode) ? mode : "login";
}

export default function AuthPage() {
  return <AuthForm />;
}

// Runs on the server only.
// If a non-GET request is made to the route, this action function is called before
// any loader functions (if any).
export async function action({ request }: ActionFunctionArgs) {
  const authMode: AuthMode = await getAuthModeFromRequest(request);
  const formData = await request.formData();
  const credentials = Object.fromEntries(formData) as
    | LoginCredentials
    | SignupCredentials;

  try {
    // Early return for validation errors.
    // Note: the combination of "getAuthModeFromRequest" and "isAuthMode" ensures that
    // "authMode" is always a valid value (i.e. is always one of "login", "signup", or
    // "forgot-password").
    if (authMode === "login") {
      validateLoginInput(credentials as LoginCredentials);
    } else if (authMode === "signup") {
      validateSignUpInput(credentials as SignupCredentials);
    } else if (authMode === "forgot-password") {
      if (!("email" in credentials)) {
        throw new ValidationError("El correo electrónico es requerido.");
      }
    } else {
      throw new ValidationError(
        `Modo de autenticación desconocido: ${authMode}.`
      );
    }

    // For both login and signup a signed cookie is generated (see "~/server/auth.server.ts"), which
    // is sent to the client. The cookie is generated by the server, with a secret known only to the
    // server. The cookie is created such that the frontend cannot read it; it is hashed with a secret
    // known only to the server.
    return await processCredentials(authMode, credentials);
  } catch (error) {
    return Response.json({ error });
  }
}

async function processCredentials(
  authMode: AuthMode,
  credentials: LoginCredentials | SignupCredentials
) {
  if (authMode === "login") {
    return await login(credentials as LoginCredentials);
  } else if (authMode === "signup") {
    return await signup(credentials as SignupCredentials);
  } else if (authMode === "forgot-password") {
    // Put the email sending functionality here.
    //
    // And if successful, redirect the user to the login page.
    return { redirect: "/auth?mode=login" };
  }
  throw new ValidationError(`Modo de autenticación desconocido: ${authMode}.`);
}

// All errors for this route will be caught by this ErrorBoundary.
export function ErrorBoundary() {
  // To obtain the thrown object, we use the 'useRouteError' hook.
  const error = useRouteError();

  return (
    <ErrorBody
      error={error}
      routetext="_public.auth.tsx"
      className="col-start-1 col-span-12 my-3 pt-1 pb-2 px-2 rounded-md text-xs sm:text-sm md:text-base lg:text-lg"
    />
  );
}
